/* Copyright Applied Industrial Logic Limited 2002. All rights reserved. */
/*
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 51 
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

package com.ail.core.configuration;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.security.Principal;
import java.util.Collection;
import java.util.Date;
import java.util.Properties;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import com.ail.core.ConfigurationTidyService;
import com.ail.core.Core;
import com.ail.core.CoreUser;
import com.ail.core.VersionEffectiveDate;
import com.ail.core.configure.Configuration;
import com.ail.core.configure.ConfigurationHandler;
import com.ail.core.configure.ConfigurationOwner;
import com.ail.core.configure.ConfigurationSummary;
import com.ail.core.configure.ConfigurationUpdateCollisionError;
import com.ail.core.configure.Group;
import com.ail.core.configure.Parameter;
import com.ail.core.configure.Type;
import com.ail.core.configure.Types;
import com.ail.core.configure.UnknownNamespaceError;

/**
 * The tests defined here exercise the Core system's configuration handling.
 * They use the Core class as an Service or core client would.
 * Note: These tests assume that the JDBCConfigurationLoader is being used.
 */
public class TestCoreConfiguration implements CoreUser, ConfigurationOwner {
	private Core core=null;
	private VersionEffectiveDate versionEffectiveDate=null;
	private String TestNamespace="TESTNAMESPACE";
	private String namespace=null;

	/**
     * Tidy up (delete) the testdata generated by this set of tests.
     */
	private void tidyUpTestData() {
	    new ConfigurationTidyService().clearCoreNamespace().clearCoreProxyNamespace().clearNamespace(TestNamespace);
	}

    /**
     * Get the security principal associated with this instance.
     * @return The associated security principal - if defined, null otherwise.
     */
    public Principal getSecurityPrincipal() {
        return null;
    }

    /**
     * Save a known core configuration.
     * This configuration has only one parameter: TestParameter. The config.
     * is used in testing to ensure that the core's configuration is used
     * as a backstop when the local configuration doesn't define a setting.
     */
	private void writeCoreConfiguration() {
		Configuration config=new Configuration();
	    config.setName(Core.CORE_NAMESPACE);
	    config.setVersion("0.0");
        config.setSource("immediate");
		Parameter p=new Parameter();
        p.setName("TestParameter");
        p.setValue("SavedInCoreConfig");
		config.addParameter(p);
		Group g=new Group();
        g.setName("TestGroup");
		p=new Parameter();
        p.setName("GroupParameter");
		p.setValue("SavedInCoreConfig");
        g.addParameter(p);
        config.addGroup(g);
		setConfigurationNamespace(Core.CORE_NAMESPACE);
        setConfiguration(config);
        setConfigurationNamespace(TestNamespace);
    }

	/**
     * Create a simple configuration for use in tests.
     * @return An instance of a simple configuration
     */
	private Configuration createSimpleConfiguration() {
		Configuration config=new Configuration();
	    config.setName("SimpleConfigurationName");
	    config.setVersion("9.1");
        config.setTimeout(0);
        config.setSource("immediate");
		return config;
    }

	/**
     * Create a complex configuration object in the following form:
     * Configuration
	 *	<?xml version="1.0" encoding="UTF-8"?>
	 *
	 *	<Configuration version="1.1" timeout="1" >
	 *		<Parameter name="tom" value="Thomas"/>
	 *		<Parameter name="dick" value="Richard"/>
	 *		<Parameter name="harry" value="Harrold"/>
	 *
	 *		<Types>
	 *			<Type name="Yellow">
	 *				<Parameter name="class" value="com.ail.core.Yellow"/>
	 *			</Type>
	 *			<Type name="Golden">
	 *				<Parameter name="class" value="com.ail.core.Golden"/>
	 *				<Parameter name="finish" value="polished"/>
	 *			</Type>
	 *		</Types>
	 *
	 *		<Group name="plants">
	 *			<Group name="trees">
	 *				<Group name="oak">
	 *					<Parameter name="fruit" value="acorns"/>
	 *					<Parameter name="colour" value="green"/>
	 *				</Group>
	 *				<Group name="apple">
	 *					<Parameter name="fruit" value="apple"/>
	 *					<Parameter name="colour" value="green"/>
	 *				</Group>
	 *			</Group>
	 *		</Group>
	 *
	 *		<Group name="names">
	 *			<Parameter name="one" value="Dolly"/>
	 *			<Parameter name="two" value="Simpkins"/>
	 *		</Group>
	 *	</Configuration>
	 */
	private Configuration createComplexConfiguration() {
		Configuration config;
		Parameter p;
		Types ts;
        Type t;
        Group g;

    	config=new Configuration();
		config.setVersion("1.1");
        config.setTimeout(1);
        config.setSource("immediate");
        
        p=new Parameter();
        p.setName("tom");
        p.setValue("Thomas");
        config.addParameter(p);
		p=new Parameter();
		p.setName("dick");
        p.setValue("Richard");
        config.addParameter(p);
		p=new Parameter();
		p.setName("harry");
        p.setValue("Harold");
        config.addParameter(p);
		ts=new Types();
        t=new Type();
        t.setName("Yellow");
        p=new Parameter();
        p.setName("class");
        p.setValue("com.ail.core.Yellow");
        t.addParameter(p);
		ts.addType(t);
        t=new Type();
        t.setName("Golden");
        p=new Parameter();
        p.setName("class");
        p.setValue("com.ail.core.Golder");
        t.addParameter(p);
        p=new Parameter();
        p.setName("finish");
        p.setValue("polished");
        t.addParameter(p);
		ts.addType(t);
	 	g=new Group();
        g.setName("plants");
        config.addGroup(g);
        Group gt=new Group();
        gt.setName("trees");
        g.addGroup(gt);
        Group gto=new Group();
        gto.setName("oak");
		gt.addGroup(gto);
        p=new Parameter();
        p.setName("fruit");
        p.setValue("acorns");
		gto.addParameter(p);
        p=new Parameter();
        p.setName("colour");
        p.setValue("green");
		gto.addParameter(p);
		Group gta=new Group();
		gta.setName("apple");
        gt.addGroup(gta);
        p=new Parameter();
        p.setName("colour");
        p.setValue("green");
		gta.addParameter(p);
        p=new Parameter();
        p.setName("fruit");
        p.setValue("apple");
		gta.addParameter(p);
		g=new Group();
        g.setName("names");
        config.addGroup(g);
        p=new Parameter();
        p.setName("one");
        p.setValue("Dolly");
        g.addParameter(p);
        p=new Parameter();
        p.setName("two");
        p.setValue("Simpkins");
        g.addParameter(p);

		return config;
    }

    /**
     * Sets up the fixture (run before every test).
     * Get an instance of Core, and delete the testnamespace from the config table.
     */
    @Before
    public void setUp() {
		ConfigurationHandler.resetCache();
		core=new Core(this);
		versionEffectiveDate=new VersionEffectiveDate();
		tidyUpTestData();
		setConfigurationNamespace(TestNamespace);
		writeCoreConfiguration();
    }

    /**
     * Tears down the fixture (run after each test finishes)
     */
    @After
    public void tearDown() {
		tidyUpTestData();
    }

	/**
     * Method demanded by the CoreUser interface.
     * @return A date to use to select the current version of config info.
     */
    public VersionEffectiveDate getVersionEffectiveDate() {
		return versionEffectiveDate;
    }

	/**
     * Method demanded by the ConfigurationOwner interface.
	 * @param config Configuration to use from now on.
     */
    public void setConfiguration(Configuration config) {
		core.setConfiguration(config);	
    }

	/**
     * Method demanded by the ConfigurationOwner interface.
	 * @return The current configuration (at versionEffectiveDate).
     */
    public Configuration getConfiguration() {
		return core.getConfiguration();
    }

	/**
     * Method demanded by the ConfigurationOwner interface.
	 * @return The configuration namespace we're using
     */
    public String getConfigurationNamespace() {
		return namespace;
    }

	private void setConfigurationNamespace(String namespace) {
        this.namespace=namespace;
    }

	/**
     * Method demanded by the ConfigurationOwner interface.
     */
    public void resetConfiguration() {
		setConfiguration(createSimpleConfiguration());
    }


    /**
     * Test Configuration class itself.
     *
     */
    @Test
    public void testConfigurationClass() throws Exception {
        Configuration config=this.createComplexConfiguration();
        assertEquals("green", config.findParameter("plants.trees.oak.colour").getValue());
        assertEquals("Dolly", config.findParameter("names.one").getValue());
        assertEquals("acorns", config.findGroup("plants.trees.oak").findParameter("fruit").getValue());
        assertEquals("apple", config.findGroup("plants.trees").findParameter("apple.fruit").getValue());
        assertNotNull(config.getSource());
    }

	/**
     * Check that the core class can be used to save configuration.
     * This test does not exsure that the configuration was stored OK,
     * just that the store doesn't throw exceptions.
     * <ol>
     * <li>Create a configuration</li>
	 * <li>Save the configuration (Core.saveConfiguration).</li>
     * <li>Fail if any exceptions are thrown.</li>
	 * </ol>
     */
    @Test
    public void testSaveConfiguration() {
		try {
			core.setConfiguration(this.createSimpleConfiguration());
        }
		catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
	 * Check that configuration can be save and re-loaded.
     * <ol>
     * <li>Create a simple configuration.</li>
     * <li>Save the configuration.</li>
	 * <li>sleep for 1ms, the set versionEffectiveDate to now.
     * <li>Load the configuration.</li>
     * <li>Fail if the loaded configuration is different from the saved one.</li>
     * <li>Fail if any exceptions are thrown.</li>
     * </ol>
     */
    @Test
	public void testSaveAndLoadConfiguration() {
        try {
            core.setConfiguration(this.createSimpleConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            Configuration conf=core.getConfiguration();
            assertEquals("9.1", conf.getVersion());
            assertEquals("SimpleConfigurationName", conf.getName());
            assertNotNull(conf.getSource());
        }
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
	}

	/**
	 * Check that configuration access is correctly based on version effective
     * date.<p>
     * Configurations are loaded with respect to their name, and the dates when
	 * they are valid. When a configuration is saved, only its start-date is
     * filled in, the end-date is set when the configuration is updated. When 
     * a caller requests something from the core that requires the core to read
     * from configuration it (the core) loadeds the configuration with respect 
     * to the date returned by the caller's getVersionEffectiveDate method.
     * So, if you set your versionEffectiveDate to now, save your configuration
     * and then try to re-load it you will find that it doesn't change.
     * <ol>
     * <li>Create three different configurations 3ms apart, note the time
     * when each was saved.</li>
	 * <li>Try to load the configuration.</li>
     * <li>Fail if no execption is thrown - versionEffectiveDate is still set to
     * when the test began, when there was no configuration.</li>
     * <li>set versionEffectiveDate to each of the saved times in turn and load
     * the configuration.</li>
     * <li>Fail if any exceptions are thrown.</li>
     * <li>Fail if the configurations loaded are not the same as they were saved.</li>
     * </ol>
     */
    @Test
	public void testSaveAndLoadVersioningConfiguration() {
		String[] name={"Tom", "Dick", "Harry"};
        VersionEffectiveDate[] when=new VersionEffectiveDate[3];

		try {
			for(int i=0 ; i<3 ; i++) {
				Configuration config=createSimpleConfiguration();
	            config.setName(name[i]);
	            core.setConfiguration(config);
				when[i]=new VersionEffectiveDate();
            }

			try {
            	core.getConfiguration();
			}
            catch(UnknownNamespaceError e) {
                // ignore this, its what we want.
            }
            catch(Throwable e) {
                fail("Unexpected exception:"+e);
            }

			for(int i=0 ; i<3 ; i++) {
                versionEffectiveDate=when[i];
	            Configuration conf=core.getConfiguration();
	            assertEquals("9.1", conf.getVersion());
            	assertEquals(name[i], conf.getName());
			}
        }
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
	}

	/**
     * Test to ensure that "simple" parameters are retrieved correctly
     * from configuration.
     * "Simple" parameters are parameters at the root level of the configuration,
     * i.e. they are not in sub-groups.
     * <ol>
     * <li>Set the current configuration to the on defined in <code>this.createComplexConfiguration()</code></li>
     * <li>Set the version effective date to now.</li>
     * <li>Read the values of the 'tom', 'dick', and 'harry' root parameters.</li>
     * <li>Fail if 'tom' doesn't return 'Thomas', 'dick' doesn't return 'Richard', or 'harry' doesn't return 'harold'.</li>
	 * <li>Fail if any exception are thrown.</li>
     * </ol>
     */
    @Test
	public void testGettingSimpleParameterValuesFromConfiguration() throws Exception {
        core.setConfiguration(this.createComplexConfiguration());
        versionEffectiveDate=new VersionEffectiveDate(new Date());
        assertEquals("Thomas", core.getParameter("tom").getValue());
        assertEquals("Richard", core.getParameter("dick").getValue());
        assertEquals("Harold", core.getParameter("harry").getValue());
        assertEquals("Thomas", core.getParameterValue("tom"));
        assertEquals("Richard", core.getParameterValue("dick"));
        assertEquals("Harold", core.getParameterValue("harry"));
        assertEquals("Thomas", core.getParameterValue("tom", "dummy"));
        assertEquals("Richard", core.getParameterValue("dick", "dummy"));
        assertEquals("Harold", core.getParameterValue("harry", "dummy"));
        assertNotNull(core.getConfiguration().getSource());
    }

	/**
     * Check that an attempt to fetch a parameter that isn't defined is handled
     * correctly.
	 * When an attempt is made to retrieve an undefined parameter, <code>code.getParameter()</code>
     * should return a null.
     * <ol>
     * <li>Set the current configuration to the on defined in <code>this.createComplexConfiguration()</code></li>
     * <li>Set the version effective date to now.</li>
     * <li>Attempt to fetch the parameter "param-that-does-not-exist".</li>
     * <li>Fail if the parameter returned is not null.</li>
     * <li>Fail if any exceptions are thrown.</li>
     * </ol>
     */
    @Test
	public void testGettingSimpleParametersThatDontExist() throws Exception {
        core.setConfiguration(this.createComplexConfiguration());
        versionEffectiveDate=new VersionEffectiveDate();
        Parameter p=core.getParameter("param-that-does-not-exist");
        assertNull(p);
        assertNull(core.getParameterValue("param-that-does-not-exist"));
        assertEquals("mydefault", core.getParameterValue("param-that-does-not-exist", "mydefault"));
    }

	/**
     * Test to ensure that "complex" parameters are retrieved correctly
     * from configuration.
     * "Simple" parameters are parameters nested within groups which are located
     * using a dot sperated path.
     * <ol>
     * <li>Set the current configuration to the on defined in <code>this.createComplexConfiguration()</code></li>
     * <li>Set the version effective date to now.</li>
     * <li>Read the values of the 'tom', 'dick', and 'harry' root parameters.</li>
     * <li>Fail if 'tom' doesn't return 'Thomas', 'dick' doesn't return 'Richard', or 'harry' doesn't return 'harold'.</li>
	 * <li>Fail if any excepations are thrown.</li>
     * </ol>
     */
    @Test
	public void testGettingComplexParameterValuesFromConfiguration() {
		try {
            core.setConfiguration(this.createComplexConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            assertEquals("green", core.getParameter("plants.trees.oak.colour").getValue());
            assertEquals("Dolly", core.getParameter("names.one").getValue());
            assertEquals("green", core.getParameterValue("plants.trees.oak.colour"));
            assertEquals("Dolly", core.getParameterValue("names.one"));
            assertEquals("green", core.getParameterValue("plants.trees.oak.colour", "dummy"));
            assertEquals("Dolly", core.getParameterValue("names.one", "dummy"));
		}
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

    /**
     * Test to ensure that the configuration's source is correctly returned by the core. This source
     * indicates where the configuration be being used by the core was loaded from.
     * <ol>
     * <li>Set the current configuration to the on defined in <code>this.createComplexConfiguration()</code></li>
     * <li>Set the version effective date to now.</li>
     * <li>Fail if the source isn't set to immediate.</li>
     * <li>Fail if 'tom' doesn't return 'Thomas', 'dick' doesn't return 'Richard', or 'harry' doesn't return 'harold'.</li>
     * <li>Fail if any exceptions are thrown.</li>
     * </ol>
     */
    @Test
    public void testGettingConfigurationSource() {
        try {
            core.setConfiguration(this.createComplexConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            assertTrue(core.getConfigurationSource().contains("immediate"));
        }
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
     * Test to ensure that "simple" groups are retrieved correctly
     * from configuration.
     * "Simple" groups are groups at the root level of the configuration,
     * i.e. they are not in sub-groups.
     * <ol>
     * <li>Set the current configuration to the on defined in <code>this.createComplexConfiguration()</code></li>
     * <li>Set the version effective date to now.</li>
	 * <li>Fetch the "plants" group from configuration.</li>
     * <li>Fail if the name of the group returned is not "plants".</li>
	 * <li>Fetch the "names" group from configuration.</li>
     * <li>Fail if the name of the group returned is not "names".</li>
	 * <li>Fail if any excepations are thrown.</li>
     * </ol>
     */
    @Test
	public void testGettingSimpleGroupFromConfiguration() {
		try {
            core.setConfiguration(this.createComplexConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            Group g1=core.getGroup("plants");
            assertEquals("plants", g1.getName());
            Group g2=core.getGroup("names");
            assertEquals("names", g2.getName());
		}
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
     * Test to ensure that "complex" groups are retrieved correctly
     * from configuration.
     * "complex" groups are groups which are tested within other groups.
     * <ol>
     * <li>Set the current configuration to the on defined in <code>this.createComplexConfiguration()</code></li>
     * <li>Set the version effective date to now.</li>
	 * <li>Fetch the "plants.trees.oak" group from configuration.</li>
     * <li>Fail if the name of the group returned is not "oak".</li>
	 * <li>Fetch the "plants.trees.apple" group from configuration.</li>
     * <li>Fail if the name of the group returned is not "apple".</li>
	 * <li>Fail if any excepations are thrown.</li>
     * </ol>
     */
    @Test
	public void testGettingComplexGroupFromConfiguration() {
		try {
            core.setConfiguration(this.createComplexConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            Group g1=core.getGroup("plants.trees.oak");
            assertEquals("oak", g1.getName());
            Group g2=core.getGroup("plants.trees.apple");
            assertEquals("apple", g2.getName());
		}
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
     * Check that an attempt to fetch a group that isn't defined is handled
     * correctly.
	 * When an attempt is made to retrieve an undefined group, <code>code.getGroup()</code>
     * should return a null.
     * <ol>
     * <li>Set the current configuration to the on defined in <code>this.createComplexConfiguration()</code></li>
     * <li>Set the version effective date to now.</li>
     * <li>Attempt to fetch the group "param-that-does-not-exist".</li>
     * <li>Fail if the group returned is not null.</li>
     * <li>Fail if any exceptions are thrown.</li>
     * </ol>
     */
    @Test
	public void testGettingSimpleGroupThatDontExist() {
		try {
            core.setConfiguration(this.createComplexConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            Group g=core.getGroup("group-that-does-not-exist");
            assertNull(g);
		}
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
     * Test that a group's parameters can be retrieved as a java.util.Properties.
     * <ol>
     * <li>Set the current configuration to the on defined in <code>this.createComplexConfiguration()</code></li>
     * <li>Set the version effective date to now.</li>
     * <li>Attempt to the parameters from the root configuration as properties.</li>
	 * <li>Fail if null is returned</li>
     * <li>Fail if the properties tom=Thomas, dick=Richard, and harry=Harold are not found.
     * <li>Fail if any exceptions are thrown.</li>
     * </ol>
     */
    @Test
	public void testGettingParametersAsProperties() {
		try {
            core.setConfiguration(this.createComplexConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            Properties p=core.getParametersAsProperties("");
            assertNotNull(p);
            assertEquals("Thomas", p.getProperty("tom"));
            assertEquals("Richard", p.getProperty("dick"));
            assertEquals("Harold", p.getProperty("harry"));
		}
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
     * Test that attempting to fetch Parameters as Properties for a group
     * that doesn't exist returns a null.
     * <ol>
     * <li>Set the current configuration to the on defined in <code>this.createComplexConfiguration()</code></li>
     * <li>Set the version effective date to now.</li>
     * <li>Attempt to the parameters for the group "group-that-does-not-exist".</li>
	 * <li>Fail if the return is not null.</li>
     * <li>Fail if any exceptions are thrown.</li>
     * </ol>
     */
    @Test
   public void testGettingParametersAsPropertiesForEmptyGroup() {
		try {
            core.setConfiguration(this.createComplexConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            Properties p=core.getParametersAsProperties("group-that-does-not-exist");
            assertNull(p);
		}
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
     * Test that attempting to fetch Parameters as Properties for a group
     * that doesn't exist returns a null.
     * <ol>
     * <li>Set the current configuration to the on defined in <code>this.createComplexConfiguration()</code></li>
     * <li>Set the version effective date to now.</li>
     * <li>Attempt to the parameters for the group "plants".</li>
	 * <li>Fail if the return is null.</li>
     * <li>Fail if any exceptions are thrown.</li>
     * </ol>
     */
    @Test
    public void testGettingParametersAsPropertiesGroupThatDontExist() {
		try {
            core.setConfiguration(this.createComplexConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            Properties p=core.getParametersAsProperties("plants");
            assertNotNull(p);
		}
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
     * If a request is made by a configuration user for a setting (parameter,
     * group, etc) which is not defined in that user's configuration, the core
     * should check it's own configuration. This test ensures that this
     * is the case for parameters.<p>
     * The setup method saves a core configuration which defines TestParameter
     * with the value 'SavedInCoreConfig'.
	 * <ol>
     * <li>Save a configuration that doesn't define "TestParameter".</li>
     * <li>Get the parameter "TestParameter".</li>
     * <li>Fail if null is returned, or if the parameter's value is not "SavedInCoreConfig"</li>
     * <li>Save a configuration that defines "TestParameter" as "SavedLocally"</li>
	 * <li>Get the parameter "TestParameter".</li>
     * <li>Fail if null is returned, or if the parameter's value is not "SavedLocally"</li>
     * <li>Fail if any exceptions are thrown.</li>
     * </ol>
     */
    @Test
	public void testParameterConfigurationBackStop() {
        try {
            Parameter p=null;
            
            core.setConfiguration(this.createSimpleConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            p=core.getParameter("TestParameter");
            assertNotNull(p);
            assertEquals("SavedInCoreConfig", p.getValue());
            
            Configuration c=createSimpleConfiguration();
            p=new Parameter();
            p.setName("TestParameter");
            p.setValue("SavedLocally");
            c.addParameter(p);
            core.setConfiguration(c);
            versionEffectiveDate=new VersionEffectiveDate();
            
            p=core.getParameter("TestParameter");
            assertNotNull(p);
            assertEquals("SavedLocally", p.getValue());
        }
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
     * If a request is made by a configuration user for a setting (parameter,
     * group, etc) which is not defined in that user's configuration, the core
     * should check it's own configuration. This test ensures that this
     * is the case for groups.<p>
     * The setup method saves a core configuration which defines TestGroup.
	 * <ol>
     * <li>Save a configuration that doesn't define "TestGroup".</li>
     * <li>Get the group "TestGroup".</li>
     * <li>Fail if null is returned.</li>
     * <li>Save a configuration that defines "TestGroup" as "SavedLocally"</li>
	 * <li>Get the parameter "TestParameter".</li>
     * <li>Fail if null is returned, or if the parameter's value is not "SavedLocally"</li>
     * <li>Fail if any exceptions are thrown.</li>
     * </ol>
     */
    @Test
	public void testGroupConfigurationBackStop() {
        try {
            Parameter p=null;
            
            core.setConfiguration(this.createSimpleConfiguration());
            versionEffectiveDate=new VersionEffectiveDate();
            p=core.getParameter("TestGroup.GroupParameter");
            assertNotNull(p);
            assertEquals("SavedInCoreConfig", p.getValue());
            
            Configuration c=createSimpleConfiguration();
            Group g=new Group();
            g.setName("TestGroup");
            p=new Parameter();
            p.setName("GroupParameter");
            p.setValue("SavedLocally");
            g.addParameter(p);
            c.addGroup(g);
            core.setConfiguration(c);
            versionEffectiveDate=new VersionEffectiveDate();
            
            p=core.getParameter("TestGroup.GroupParameter");
            assertNotNull(p);
            assertEquals("SavedLocally", p.getValue());
        }
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
     * Check that the configuration timeout feature is working.
     * Configurations specify their own timeout value which defines when they
     * should be reloaded. Updating a configuration in the database (via
     * saveConfiguration) does not make that configuration live, it simply
     * updates the database records. It will only become live when the current
     * configuration's timeout expires, and forces a re-load.
     * <ol>
     * <li>Create a configuration with a TestParameter set to "one".</li>
     * <li>Save the configuration with a timeout of 100ms.</li>
     * <li>Fetch "TestParameter", and check that its value is "one".<li>
     * <li>Create a configuration with TestParameter set to "two".<li>
     * <li>Save the configuration.</li>
	 * <li>Fetch "TestParameter", and check that its value is still "one".</li>
     * <li>Sleep for 100ms.</li>
     * <li>Fetch "TestParameter", and check that its value is now "two".</li>
     * <li>Fail if any exceptions are thrown.</li>
     * </ol>
     */
    @Test
    public void testConfigurationTimeout() {
        try {
            Parameter p=null;
            Configuration config=null;
            
            config=this.createSimpleConfiguration();
            config.setTimeout(1000);
            p=new Parameter();
            p.setName("TestParameter");
            p.setValue("one");
            config.addParameter(p);
            core.setConfiguration(config);
            
            versionEffectiveDate=new VersionEffectiveDate();
            assertEquals("one", core.getParameter("TestParameter").getValue());
            
            config=this.createSimpleConfiguration();
            config.setTimeout(1000);
            p=new Parameter();
            p.setName("TestParameter");
            p.setValue("two");
            config.addParameter(p);
            core.setConfiguration(config);
            
            versionEffectiveDate=new VersionEffectiveDate();
            assertEquals("one", core.getParameter("TestParameter").getValue());
            
            Thread.sleep(1000);
            
            assertEquals("two", core.getParameter("TestParameter").getValue());
        }
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

	/**
	 * Test the effectiveness of the configuration timeout cache.
     * With a timeout set to zero the database should be hit on each request for
     * 'new' configuration. Setting the timeout to a more realistic value (1000),
     * should result in database hits only every 1000ms.
     * <ol>
     * <li>Save a configuration with a timeout of zero.</li>
     * <li>Time how long it takes to make 1000000 configuration queries.</li>
     * <li>Save the same configuration again, but this time with a timeout of 1000.</li>
     * <li>Time how long it now takes to make 1000000 configuration queries.</li>
     * <li>File if any exceptions are thrown.</li>
     * <li>Fail if the second time is more than 5 times the first.</li>
     * </ol>
     */
    @Test
	public void testTimoutCachePerformace() {
        try {
            Parameter p=null;
            Configuration config=null;
            long startAt, endAt, firstLoop, secondLoop;
            
            config=this.createSimpleConfiguration();
            config.setTimeout(0);
            p=new Parameter();
            p.setName("TestParameter");
            p.setValue("one");
            config.addParameter(p);
            core.setConfiguration(config);
            
            versionEffectiveDate=new VersionEffectiveDate();
            assertEquals("one", core.getParameter("TestParameter").getValue());
            startAt=System.currentTimeMillis();
            for(int i=0 ; i<1000000 ; i++) {
                assertEquals("one", core.getParameter("TestParameter").getValue());
            }
            endAt=System.currentTimeMillis();
            firstLoop=endAt-startAt;
            
            config=this.createSimpleConfiguration();
            config.setTimeout(100000);
            p=new Parameter();
            p.setName("TestParameter");
            p.setValue("two");
            config.addParameter(p);
            core.setConfiguration(config);
            
            versionEffectiveDate=new VersionEffectiveDate();
            assertEquals("two", core.getParameter("TestParameter").getValue());
            startAt=System.currentTimeMillis();
            for(int i=0 ; i<1000000 ; i++) {
                assertEquals("two", core.getParameter("TestParameter").getValue());
            }
            endAt=System.currentTimeMillis();
            secondLoop=endAt-startAt;
            
            // second loop should be at least 50 times faster than the first
            System.out.println("Caching effect was "+secondLoop+" (cached) v. "+firstLoop+" (uncached)");
            assertTrue("Caching not effective: was "+secondLoop+" max is:"+firstLoop, secondLoop*5 < firstLoop);
        }
        catch(Throwable e) {
            fail("Unexpected exception:"+e);
        }
    }

    /**
     * Check that the configure system correctly detects and prevents
     * update collisions. This is the scenario where:<ol>
     * <li>User A reads configuration.</li>
     * <li>User B reads configuration.</li>
     * <li>User A modifies their in memory configuration, and saves.</li>
     * <li>User B modifies their in memory configuration, and attempts to save. <b>*Error should be thrown here*</b></li>
     * </ol>
     * @throws Exception
     */
    @Test
    public void testUpdateCollisionDetection() throws Exception {
        Parameter p=null;
        Configuration config=null;

        config=this.createSimpleConfiguration();
        config.setTimeout(4000);
        core.setConfiguration(config);

        versionEffectiveDate=new VersionEffectiveDate();

        Configuration con1=core.getConfiguration();
        p=new Parameter();
        p.setName("Con1Parameter");
        p.setValue("one");
        con1.addParameter(p);

        Thread.sleep(250);

        Configuration con2=core.getConfiguration();
        p=new Parameter();
        p.setName("Con2Parameter");
        p.setValue("two");
        con2.addParameter(p);

        Thread.sleep(250);

        core.setConfiguration(con1);

        Thread.sleep(250);

        try {
            core.setConfiguration(con2);
            fail("collision not detected");
        }
        catch(ConfigurationUpdateCollisionError e) {
            // this is good!
        }
    }

    /**
     * As new version of a configuration are stored, the core keeps hold of the
     * old ones - so that callers who ask for yesterday's configuration (by setting
     * their versionEffectiveDate to yesterdate) will get yesterdays configuration.
     * It also offers a service to return details of all the versions of a specific
     * configuration that it knows about. This test creates a number of configurations, 
     * then calls the history service and checks that the details returned match up
     * this those of the configurations it created.
     * @throws Exception
     */
    @Test
    public void testConfigurationHistory() throws Exception {
        Configuration config=null;

        // create a configuration and store it.
        config=this.createSimpleConfiguration();

        core.setConfiguration(config);
        Thread.sleep(250);
        core.setConfiguration(config);
        Thread.sleep(250);
        core.setConfiguration(config);
        Thread.sleep(250);
        core.setConfiguration(config);

        Collection<ConfigurationSummary> c=ConfigurationHandler.getInstance().getNamespacesHistorySummary(TestNamespace);
        assertNotNull(c);
        assertEquals(4, c.size());
    }
    
    /**
     * As of version 2.0 of the core, configurations support the notion of inheritance. That is, a configuration
     * names another as being it's parent. The parent may in turn inherit from another and so on.
     * This text checks that basic inheritance works.
     * <ul>
     * <li>Define two configurations: A and B. Configuration A defines a parameter: "ParamA", and configuration B defines
     * a paremeter: "ParamB". Configuration B is set to inherit from A.</li>
     * <li>Select B as our current configuration (by setting the namespace).</li>
     * <li>Assert that both ParamA and ParamB are visible, fail it either is not.</li>
     * <li>Select A as our current configuration.</li>
     * <li>Assert that ParamA is visible, by ParamB is not. Fail if this is not the case.
     * </ul>
     */
    @Test
    public void testConfigurationInheritance() throws Exception {
        Parameter p=null;
        Group g=null;
        Configuration config=null;

        setConfigurationNamespace("A");
        config=this.createSimpleConfiguration();
        p=new Parameter();
        p.setName("ParamA");
        p.setValue("parama");
        config.addParameter(p);
        g=new Group();
        g.setName("GroupA");
        p=new Parameter();
        p.setName("GroupAParameter");
        p.setValue("groupaparameter");
        g.addParameter(p);
        config.addGroup(g);
        core.setConfiguration(config);
        versionEffectiveDate=new VersionEffectiveDate();

        setConfigurationNamespace("B");
        config=this.createSimpleConfiguration();
        config.setParentNamespace("A");
        p=new Parameter();
        p.setName("ParamB");
        p.setValue("paramb");
        config.addParameter(p);
        g=new Group();
        g.setName("GroupB");
        p=new Parameter();
        p.setName("GroupBParameter");
        p.setValue("groupbparameter");
        g.addParameter(p);
        config.addGroup(g);
        core.setConfiguration(config);
        
        setConfigurationNamespace("C");
        config=this.createSimpleConfiguration();
        config.setParentNamespace("B");
        p=new Parameter();
        p.setName("ParamC");
        p.setValue("paramc");
        config.addParameter(p);
        g=new Group();
        g.setName("GroupC");
        p=new Parameter();
        p.setName("GroupCParameter");
        p.setValue("groupcparameter");
        g.addParameter(p);
        config.addGroup(g);
        core.setConfiguration(config);

        versionEffectiveDate=new VersionEffectiveDate();
        
        setConfigurationNamespace("C");
        assertEquals("paramb", core.getParameter("ParamB").getValue());
        assertEquals("parama", core.getParameter("ParamA").getValue());
        assertEquals("paramc", core.getParameter("ParamC").getValue());
        assertNotNull(core.getGroup("GroupA"));
        assertNotNull(core.getGroup("GroupB"));
        assertNotNull(core.getGroup("GroupC"));
    
        setConfigurationNamespace("B");
        assertEquals("paramb", core.getParameter("ParamB").getValue());
        assertEquals("parama", core.getParameter("ParamA").getValue());
        assertNull(core.getParameter("ParamC"));
        assertNotNull(core.getGroup("GroupA"));
        assertNotNull(core.getGroup("GroupB"));
        assertNull(core.getGroup("GroupC"));
    
        setConfigurationNamespace("A");
        assertEquals("parama", core.getParameter("ParamA").getValue());
        assertNull(core.getParameter("ParamB"));
        assertNull(core.getParameter("ParamC"));
        assertNotNull(core.getGroup("GroupA"));
        assertNull(core.getGroup("GroupB"));
        assertNull(core.getGroup("GroupC"));
    }
    
    @Test
    public void testGetParameterAsPropertiesHappyPath() {
        Configuration config=createComplexConfiguration();
        
        Properties p=config.findGroup("plants.trees.oak").getParameterAsProperties();
        assertEquals(2, p.size());
        assertEquals("acorns", p.get("fruit"));
        assertEquals("green", p.get("colour"));
    }

    @Test
    public void testGetParameterAsPropertiesForEmptyGroup() {
        Configuration config=createComplexConfiguration();
        
        Properties p=config.findGroup("plants.trees").getParameterAsProperties();
        assertEquals(0, p.size());
    }
}


